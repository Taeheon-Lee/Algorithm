"Kruskal 크루스칼 알고리즘"

# 최소 신장 트리(Minimum Spanning Tree)의 하나로 그래프의 모든 간선 중 가중치가 최소인 간선을 하나씩 더해가면서 최소 신장 트리를 만드는 방식
# 먼저 간선의 가중치를 기준으로 정렬한 후 최소 신장 트리가 될 때까지 최소 가중치 간선을 하나씩 선택해 감
# 선택한 간선과 연결되어 있지 않은 간선이라도 가중치가 작은 간선을 순서대로 신장 트리에 추가
# 전체 n개의 정점에 대하여 n-1개의 간선이 연결되면 종료

# 그래프에서 사이클의 판단은 서로소 집합 알고리즘(Union-Find)을 사용함
# 이 알고리즘은 여러 노드가 존재할 때 두개의 노드를 선택해 루트를 확인하고 현재 서로 같은 그래프에 속하는 판별
# Union 연산은 두 개의 집합을 하나의 집합으로 함치는 연산
# Find 연산은 수행하면서 루트까지 올가는 경로 상의 각 노드의 부모 노드를 루트로 갱신, 이를 경로 압축이라 함
# 경로 압축을 통하여 수행 시간을 단축시킬 수 있음

def find(node, p):
    "경로 압축을 위한 연결된 제일 최상단 부모 노드를 찾는 함수"
    while node != p[node]:                                                  # 노드의 부모가 자기 자신 노드, 즉 제일 최상단 부모 노드일 때까지
        node = p[node]                                                      # 노드의 부모 노드로 이동
    return node

def union(n, m, p):
    "경로가 연결되면 하나의 집합이 되기 때문에 하나의 집합으로 합치는 함수"
    root1 = find(n, p)                                                      # 노드 n의 부모 노드 탐색
    root2 = find(m, p)                                                      # 노드 m의 부모 노드 탐색
    p[root2] = root1                                                        # 해당 노드들을 하나의 집합으로 합치기 위하여 임시적으로 하나의 최상단 부모 노드를 같은 노드로 만듬
                                                                            # 이렇게 만들 경우, 이제 사이클이 발생했을 때, 같은 집합에 속해져 있는 것으로 판단되어 제거 가능함

def kruskal(graph, node_num):
    graph = sorted(graph, key=lambda x:x[2])                                # 그래프를 가중치 기준으로 오름차순 정렬
    mst = []                                                                # 최소 신장 트리 리스트 생성
    edge_cnt = 0                                                            # 노드 간선 개수 카운트
    mst_cost = 0                                                            # 최소 신장 트리 비용

    parent = [0]                                                            # 각 노드의 최상단 루트를 입력할 리스트 생성
    for i in range(1, node_num+1):                                          # 초기 탐색은 선택 경로가 없어 아무 경로도 연결되지 않은 상태이기 때문에 각 노드를 자신의 최상단 루트로 초기화
        parent.append(i)
    
    while edge_cnt != node_num-1:                                           # 선택된 간선의 개수가 노드의 개수-1이 될 경우 종료
        n, m, wt = graph.pop(0)                                             # 출발 노드와 도착 노드, 가중치를 그래프에서 가져옴
        if find(n, parent) != find(m, parent):                              # 각 노드의 현재 최상단 부모 노드가 다를 경우, 즉 사이클이 발생하지 않은 경우 (같은 집합일 때)
            union(n, m, parent)                                             # 경로를 선택하고 두개의 노드를 하나의 집합으로 합침
            mst.append((n, m))                                              # 경로를 최소 신장 트리 리스트에 입력
            mst_cost += wt                                                  # 가중치 누적
            edge_cnt += 1                                                   # 선택된 간선 추가
    return [mst, mst_cost]                                                  # 최소 신장 트리 및 가중치 리턴

graph = [(1,2,13),(1,3,5),(2,4,9),(3,4,15),(3,5,3),(4,5,1),(4,6,7),(5,6,2)] # 그래프 입력
node_cnt = 6                                                                # 노드 개수 입력
ans = kruskal(graph, node_cnt)
print("Minimum Spanning Tree", ans[0])
print("Weight Cost", ans[1])